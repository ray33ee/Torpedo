

#[cfg(test)]
mod torpedo_tests {
    use native_tls::{TlsConnector, Protocol};
    use std::net::{TcpStream, IpAddr, Ipv6Addr, Ipv4Addr};
    use std::io::{Write, Read};
    use crate::cells::{TorCell, Command};
    use torserde::{NLengthVector, VersionsVector};
    use torserde::TorSerde;
    use chrono::Local;
    use std::str::FromStr;

    use sha1::Digest;
    use sha1::digest::DynDigest;

    use crate::custom_crypto::kdf_tor;
    use crate::cellcrypto::CellCrypto;
    use std::cell::Cell;
    use std::convert::TryInto;
    use crate::cells::EndReason::TorProtocol;

    #[test]
    fn test_cells_coms() {
        let connector = TlsConnector::builder()
            .danger_accept_invalid_hostnames(true)
            .danger_accept_invalid_certs(true)
            .min_protocol_version(Some(Protocol::Tlsv12))
            .build().unwrap();

        let stream = TcpStream::connect("1.65.176.249:9001").unwrap();
        let mut stream = connector.connect("", stream).unwrap();


        TorCell::new(0, Command::Versions {version_list: VersionsVector::from(vec![3, 4]) }).into_stream(& mut stream, 3);

        let versions = TorCell::from_stream(& mut stream, 3);

        println!("{:?}", versions);

        let certs = TorCell::from_stream(& mut stream, 4);

        println!("{:?}", certs);

        let auth = TorCell::from_stream(& mut stream, 4);

        println!("{:?}", auth);

        let netinfo = TorCell::from_stream(& mut stream, 4);

        println!("{:?}", netinfo);

        TorCell::new(0, Command::NetInfo {
            timestamp: Local::now(),
            other_ip: IpAddr::V4(Ipv4Addr::from_str("1.65.176.249").unwrap()),
            this_ips: NLengthVector::from(vec![IpAddr::V4(Ipv4Addr::from_str("0.0.0.0").unwrap())]) }).into_stream(& mut stream, 4);

        let skin = [3u8; 20];

        TorCell::new(0x80000001, Command::CreateFast {onion_skin: skin}).into_stream(& mut stream, 4);

        let created_fast = TorCell::from_stream(& mut stream, 4);

        println!("{:?}", created_fast);

        if let Command::CreatedFast{ handshake_data } = created_fast.get_command() {

            //let handshake_data =

            let mut shared_secret = Vec::from([3u8; 20]);

            shared_secret.extend_from_slice(&handshake_data[0..20]);

            println!("secret: {:?}", shared_secret);

            let materials = kdf_tor(&shared_secret);

            let key_materials = &materials[20..92];

            let mut cell_crypto = CellCrypto::from(&materials[20..92].try_into().unwrap());

            let mut preamble: [u8; 5] = [0x80, 0, 0, 1, 3];

            let mut relay_begin_dir: [u8; 509] = [13, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ];

            cell_crypto.set_forward_digest(& mut relay_begin_dir);

            cell_crypto.encrypt(& mut relay_begin_dir);

            stream.write(&preamble);
            stream.write(&relay_begin_dir);

            let mut cell = [0u8; 514];

            stream.read(&mut cell);

            println!("cell data: {:?}", cell);

            cell_crypto.decrypt(&mut cell[5..514]);

            println!("decrypted: {:?}", cell);

            println!("validation: {}", cell_crypto.verify_backward_digest(&mut cell[5..514]));




        }




    }
/*
    #[test]
    fn test_relay_cipher() {

        use ctr::cipher::{NewCipher, StreamCipher, StreamCipherSeek};

        // `aes` crate provides AES block cipher implementation
        type Aes128Ctr = ctr::Ctr128BE<aes::Aes128>;

        let mut data = [ 122u8, 173, 13, 61, 113, 13, 35, 124, 230, 187, 116, 42, 8, 192, 198, 15, 60, 2, 72, 7, 177, 61, 55, 35, 34, 116, 33, ];


        let key = [ 134u8, 103, 242, 47, 164, 223, 229, 145, 5, 146, 222, 224, 252, 21, 153, 216, ];

        let nonce = 0u128.to_be_bytes();

        // create cipher instance
        let mut cipher = Aes128Ctr::new(key.as_ref().into(), nonce.as_ref().into());

        // apply keystream (encrypt)
        cipher.apply_keystream(&mut data);

        println!("data: {:?}", data);

        assert_eq!(data, [ 4, 0, 0, 0, 1, 253, 56, 39, 155, 0, 0, 0, 0, 0, 0, 217, 112, 242, 13, 16, 244, 197, 103, 63, 132, 38, 142, ]);


        // seek to the keystream beginning and apply it again to the `data` (decrypt)
        cipher.seek(0);
        cipher.apply_keystream(&mut data);
        assert_eq!(data, [ 122u8, 173, 13, 61, 113, 13, 35, 124, 230, 187, 116, 42, 8, 192, 198, 15, 60, 2, 72, 7, 177, 61, 55, 35, 34, 116, 33, ]);

    }
*/
    #[test]
    fn test_sha1() {
        use std::time::Instant;

        let digest = [21, 21, 16, 246, 249, 8, 88, 195, 81, 57, 59, 138, 0, 76, 196, 75, 124, 159, 194, 121, ];

        let mut hasher = sha1::Sha1::new();

        hasher.write(&digest);

        println!("hasher: {:?}", hasher.clone().finalize());

        hasher.write(&[13, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]);

        println!("hasher: {:?}", hasher.clone().finalize());

        hasher.write(&[2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 228, 71, 69, 84, 32, 47, 116, 111, 114, 47, 115, 116, 97, 116, 117, 115, 45, 118, 111, 116, 101, 47, 99, 117, 114, 114, 101, 110, 116, 47, 99, 111, 110, 115, 101, 110, 115, 117, 115, 47, 68, 53, 56, 54, 68, 49, 43, 49, 52, 67, 49, 51, 49, 43, 69, 56, 65, 57, 67, 52, 43, 69, 68, 48, 51, 66, 66, 43, 48, 50, 51, 50, 65, 70, 43, 52, 57, 48, 49, 53, 70, 43, 69, 70, 67, 66, 69, 55, 43, 50, 51, 68, 49, 53, 68, 43, 50, 55, 49, 48, 50, 66, 46, 122, 32, 72, 84, 84, 80, 47, 49, 46, 48, 13, 10, 88, 45, 79, 114, 45, 68, 105, 102, 102, 45, 70, 114, 111, 109, 45, 67, 111, 110, 115, 101, 110, 115, 117, 115, 58, 32, 55, 98, 51, 52, 101, 102, 100, 50, 52, 48, 98, 52, 52, 53, 53, 53, 100, 55, 49, 54, 57, 56, 50, 102, 52, 98, 57, 102, 56, 54, 57, 99, 53, 101, 99, 52, 102, 102, 48, 52, 54, 102, 57, 55, 52, 102, 97, 102, 100, 100, 54, 54, 97, 101, 98, 100, 102, 48, 99, 52, 50, 49, 100, 99, 13, 10, 72, 111, 115, 116, 58, 32, 57, 49, 46, 49, 52, 51, 46, 56, 56, 46, 54, 50, 13, 10, 13, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]);


        println!("hasher: {:?}", hasher.clone().finalize());
    }

    #[test]
    fn test_kdf_tor() {
        use crate::custom_crypto::kdf_tor;

        let secret = [120u8, 177, 253, 48, 253, 132, 68, 100, 0, 13, 186, 177, 249, 202, 249, 125, 25, 170, 184, 108, 70, 232, 121, 233, 100, 6, 158, 233, 138, 146, 107, 137, 220, 35, 116, 88, 176, 221, 248, 163, ];

        kdf_tor(&secret);

    }

    #[test]
    fn test_cell_crypto() {

        let key_materials: [u8; 72] = [212, 171, 216, 89, 113, 96, 239, 12, 63, 124, 35, 186, 252, 61, 89, 31, 201, 38, 99, 19, 209, 163, 115, 216, 41, 170, 223, 184, 178, 4, 115, 188, 145, 9, 148, 108, 77, 104, 108, 93, 123, 184, 156, 237, 56, 147, 122, 72, 166, 34, 208, 88, 75, 34, 187, 75, 10, 25, 176, 111, 174, 232, 115, 21, 103, 96, 237, 117, 38, 234, 42, 126, ];

        let mut payload1: [u8; 509] = [13, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ];

        let mut payload2: [u8; 509] = [2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 229, 71, 69, 84, 32, 47, 116, 111, 114, 47, 115, 116, 97, 116, 117, 115, 45, 118, 111, 116, 101, 47, 99, 117, 114, 114, 101, 110, 116, 47, 99, 111, 110, 115, 101, 110, 115, 117, 115, 47, 68, 53, 56, 54, 68, 49, 43, 49, 52, 67, 49, 51, 49, 43, 69, 56, 65, 57, 67, 52, 43, 69, 68, 48, 51, 66, 66, 43, 48, 50, 51, 50, 65, 70, 43, 52, 57, 48, 49, 53, 70, 43, 69, 70, 67, 66, 69, 55, 43, 50, 51, 68, 49, 53, 68, 43, 50, 55, 49, 48, 50, 66, 46, 122, 32, 72, 84, 84, 80, 47, 49, 46, 48, 13, 10, 88, 45, 79, 114, 45, 68, 105, 102, 102, 45, 70, 114, 111, 109, 45, 67, 111, 110, 115, 101, 110, 115, 117, 115, 58, 32, 55, 98, 51, 52, 101, 102, 100, 50, 52, 48, 98, 52, 52, 53, 53, 53, 100, 55, 49, 54, 57, 56, 50, 102, 52, 98, 57, 102, 56, 54, 57, 99, 53, 101, 99, 52, 102, 102, 48, 52, 54, 102, 57, 55, 52, 102, 97, 102, 100, 100, 54, 54, 97, 101, 98, 100, 102, 48, 99, 52, 50, 49, 100, 99, 13, 10, 72, 111, 115, 116, 58, 32, 53, 46, 49, 56, 57, 46, 49, 54, 57, 46, 49, 57, 48, 13, 10, 13, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ];

        let mut crypto_cell = CellCrypto::from(&key_materials);

        crypto_cell.set_forward_digest(& mut payload1);

        //println!("Digested1: {:?}", payload1);

        crypto_cell.encrypt(& mut payload1);

        //println!("Encrypt1: {:?}", payload1);

        crypto_cell.set_forward_digest(& mut payload2);

        //println!("Digested2: {:?}", payload2);

        crypto_cell.encrypt(& mut payload2);

        //println!("Encrypt2: {:?}", payload2);


    }

}